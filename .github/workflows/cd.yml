name: CD - Terraform

on:
  push:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - 'infra/terraform/**'
  workflow_dispatch: {}

permissions:
  id-token: write   # <-- REQUIRED for OIDC
  contents: read

jobs:
  plan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # TEMP: print the token's claims once so we can tighten the trust later
      - name: Inspect OIDC token claims (temp)
        uses: actions/github-script@v7
        with:
          script: |
            const token = await core.getIDToken('sts.amazonaws.com');
            const claims = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());
            core.info(`sub=${claims.sub}`);
            core.info(`job_workflow_ref=${claims.job_workflow_ref}`);

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::924917171175:role/GitHubActionsTerraformK8sObs
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        run: terraform -chdir=terraform init -input=false

      - name: Terraform Plan (create artifact)
        run: |
          terraform -chdir=terraform plan -input=false -out=tfplan.binary
          terraform -chdir=terraform show -no-color tfplan.binary > tfplan.txt

      - name: Upload plan artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: |
            terraform/tfplan.binary
            terraform/tfplan.txt


  apply:
    needs: plan
    runs-on: ubuntu-latest
    environment: dev  
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}   # from the 'dev' environment
          aws-region:     ${{ vars.AWS_REGION }}     # from the 'dev' environment

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Download plan artifact
        uses: actions/download-artifact@v4
        with:
          name: tfplan
          path: terraform

      - name: Terraform Init
        run: terraform -chdir=terraform init -input=false

      - name: Terraform Apply (from approved plan)
        run: terraform -chdir=terraform apply -input=false -auto-approve tfplan.binary


  test:
    name: Tests
    needs: apply
    if: needs.apply.result == 'success'
    runs-on: ubuntu-latest
    environment: dev         # <-- add this so ${{ vars.* }} resolves
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Assume AWS role (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}   # from 'dev' environment
          aws-region:     ${{ vars.AWS_REGION }}     # from 'dev' environment

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Init Terraform (read remote state)
        run: terraform -chdir=terraform init -input=false

      - name: Read Terraform outputs
        id: tfouts
        run: |
          set -euo pipefail
          CLUSTER_NAME=$(terraform -chdir=terraform output -raw cluster_name)
          echo "cluster_name=$CLUSTER_NAME" >> "$GITHUB_OUTPUT"

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Check EKS cluster and nodegroup
        run: |
          set -euo pipefail
          CLUSTER="${{ steps.tfouts.outputs.cluster_name }}"
          STATUS=$(aws eks describe-cluster --name "$CLUSTER" --query 'cluster.status' --output text)
          [ "$STATUS" = "ACTIVE" ] || { echo "Cluster status: $STATUS"; exit 1; }

          NG="${CLUSTER}-ng"
          NG_STATUS=$(aws eks describe-nodegroup --cluster-name "$CLUSTER" --nodegroup-name "$NG" --query 'nodegroup.status' --output text)
          [ "$NG_STATUS" = "ACTIVE" ] || { echo "Nodegroup status: $NG_STATUS"; exit 1; }

      - name: Configure kubeconfig
        run: aws eks update-kubeconfig --region "${{ vars.AWS_REGION }}" --name "${{ steps.tfouts.outputs.cluster_name }}"

      - name: Wait for nodes Ready and list
        run: |
          set -euo pipefail
          kubectl wait node --all --for=condition=Ready --timeout=10m
          kubectl get nodes -o wide

      - name: Check CloudWatch log group exists
        run: |
          set -euo pipefail
          LG="/aws/eks/${{ steps.tfouts.outputs.cluster_name }}/cluster"
          COUNT=$(aws logs describe-log-groups --log-group-name-prefix "$LG" --query 'length(logGroups)' --output text)
          [ "$COUNT" -ge 1 ] || { echo "Log group not found: $LG"; exit 1; }

      - name: Summary
        run: |
          {
            echo "## Post-deploy checks"
            echo ""
            echo "- Cluster: ${{ steps.tfouts.outputs.cluster_name }}"
            echo "- Region:  ${{ vars.AWS_REGION }}"
            echo "- Result:  OK"
          } >> "$GITHUB_STEP_SUMMARY"
